{"componentChunkName":"component---src-templates-presentation-js","path":"/akka-guide/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Akka Guide"},"html":"<section>\n<h1>You can do it</h1>\n<p><img src=\"/633f23f4de59aa31e81459d4443413f8/you-can-do-it.gif\" alt=\"\"></p>\n<h1>Put your Akka into it</h1>\n</section><section>\n<h1>Akka is an implementation of the \"actor model\" on .NET</h1>\n<aside class=\"notes\">\n<ul>\n<li>Port of the Scala Akka framework</li>\n<li>Open source project, Petabridge is one of the main contributors</li>\n</ul>\n</aside>\n</section><section>\n<h1>What is the actor model?</h1>\n<ul>\n<li>It is a way of structuring your app</li>\n<li>Instead of classes calling each other directly, they communicate via <strong>messages</strong> via a framework</li>\n<li>Classes that communicate in this manner are called <strong>Actors</strong></li>\n</ul>\n<aside class=\"notes\">\n<ul>\n<li>Process one message at a time</li>\n<li>When processing a message an actor can directly modify its own internal private state, but not the state of other actors</li>\n</ul>\n</aside>\n</section><section>\n<h1>Why use an actor model?</h1>\n<ul>\n<li>Actors are <strong>thread safe</strong></li>\n<li>Actors are <strong>asynchronous</strong></li>\n<li>Actor frameworks tend to have great mechanisms for <strong>error handling</strong></li>\n<li>Actors promote <strong>scalable</strong> and more loosely coupled systems</li>\n</ul>\n<aside class=\"notes\">\n<ul>\n<li>Actors allow for a very high through-put</li>\n</ul>\n</aside>\n</section><section>\n<h1>How the actor model relates to traditional code</h1>\n<ul>\n<li>Think of an actor as a function and the message as its parameters</li>\n<li>What the function does depends on the type of message it receives</li>\n<li>When an actor sends a message to another actor, think of this as one function calling another</li>\n</ul>\n<aside class=\"notes\">\n<ul>\n<li>The application is a factory</li>\n<li>Actors are workers inside factory</li>\n<li>Messages are jobs that need doing inside the factory</li>\n</ul>\n</aside>\n</section><section>\n<h1>Actor hierarchy</h1>\n<ul>\n<li>An actor can create other actors\n<ul>\n<li>The newly created actor is called the <strong>child</strong> actor</li>\n<li>The actor that created it is called the <strong>parent</strong> actor</li>\n</ul>\n</li>\n</ul>\n</section><section>\n<h1>Actor hierarchy</h1>\n<p><img src=\"/e5e841db0a053018f85c42cedaa55155/actor-layout.png\" alt=\"\"></p>\n</section><section>\n<h1>Actor hierarchy</h1>\n<p><img src=\"/9315aaa5c53d3887ebbccd1f10826e6e/actor-hierarchy.png\" alt=\"\"></p>\n<aside class=\"notes\">\n<ul>\n<li>This tree structure is great for error handling</li>\n<li>Actors can talk to siblings having actor refs passed to them in messages</li>\n</ul>\n</aside>\n</section><section>\n<h1>Error handling in actor hierarchies</h1>\n<ul>\n<li>When an actor's child throws an unhandled exception it must decide what to do. It has three options:\n<ul>\n<li>Restart all its child actors</li>\n<li>Just restart the failing child actor</li>\n<li>Escalate the error to its parent actor, who in turn has to the same three options</li>\n</ul>\n</li>\n</ul>\n</section><section>\n<h1>How are actors used?</h1>\n<p>You never instantiate an actor directly, you only ever hold a reference to it</p>\n<p><img src=\"/bb80d2b896eb2eb5e8386eac6548ab36/actor-ref.png\" alt=\"\"></p>\n<aside class=\"notes\">\n<ul>\n<li>Processing one message at a time makes actors thread safe.</li>\n<li>Since you only have a reference you cannot access or modify the internal state of an actor.</li>\n<li>Since you only have a reference the only way to interact with the actor is to send it a message.</li>\n</ul>\n</aside>\n</section><section>\n<h1>How are actors used?</h1>\n<p>The actor reference is updated when an actor restarts due to an error</p>\n<p><img src=\"/7dc070424db8563d7aaf84b4914102a7/actor-ref-new.png\" alt=\"\"></p>\n</section><section>\n<h1>Starting your first actor</h1>\n<p>If actors create other actors, how do I crete my first actor?</p>\n</section><section>\n<h1>Actor System</h1>\n<pre><code class=\"language-csharp\">using System;\nusing Akka.Actor;\n\nnamespace AkkaExamples\n{\n  internal class Program\n  {\n    private static ActorSystem _system;\n\n    private static void Main(string[] args)\n    {\n      _system = ActorSystem.Create(\"example-name\");\n      Console.CancelKeyPress += (sender, eventArgs) =>\n      {\n        eventArgs.Cancel = true; // Cancelling the event prevents the process terminating too early\n        _system.Terminate();\n      };\n      _system.WhenTerminated.Wait();\n    }\n  }\n}\n</code></pre>\n<aside class=\"notes\">\n<ul>\n<li>One actor system per app</li>\n<li>Entry point to the actor system</li>\n<li>Systems talk to each other over a network, name is used for routing</li>\n<li>Do not used system constructor, most Akka classes have a “Create” instantiation method.</li>\n</ul>\n</aside>\n</section><section>\n<h1>Actors in the Actor System</h1>\n<ul>\n<li>Actors created directly inside the Actor System are called <strong>Root Actors</strong> as they do not have a parent</li>\n<li>You can have multiple root actors</li>\n</ul>\n<aside class=\"notes\">\n<ul>\n<li>Imagine a tree with multiple root nodes (making it multiple trees)</li>\n</ul>\n</aside>\n</section><section>\n<h1>Instantiating Actors</h1>\n<ul>\n<li>Instantiating/starting an actor in Akka can be done in one of two places:\n<ul>\n<li>In the ActorSystem (for creating <em>root</em> actors)</li>\n<li>Inside Actors (for creating <em>child</em> actors)</li>\n</ul>\n</li>\n<li>Both places expose the same function to achieve this</li>\n</ul>\n</section><section>\n<h1>Actor Of</h1>\n<pre><code class=\"language-csharp\">using System;\nusing Akka.Actor;\n\nnamespace AkkaExamples\n{\n  internal class Program\n  {\n    private static ActorSystem _system;\n\n    private static void Main(string[] args)\n    {\n      _system = ActorSystem.Create(\"example-name\");\n      Console.CancelKeyPress += (sender, eventArgs) =>\n      {\n        eventArgs.Cancel = true;\n        _system.Terminate();\n      };\n\n      //Create root actor\n      IActorRef rootActor = _system.ActorOf(Props.Create(() => new ExampleRootActor()), \"example-root-actor-name\");\n\n      _system.WhenTerminated.Wait();\n    }\n  }\n}\n</code></pre>\n<aside class=\"notes\">\n<ul>\n<li>\n<p>IActorRef</p>\n<ul>\n<li>Is returned not actor type</li>\n<li>Allows no access to internal state regardless of whether its public</li>\n<li>Forces us to follow actor model correctly</li>\n<li>When a failing actor restarts the reference is updated</li>\n</ul>\n</li>\n<li>\n<p>Props</p>\n<ul>\n<li>Takes an expression on how to create Actor</li>\n<li>Akka uses the expression to create actor</li>\n<li>Used it to create new instances after failure</li>\n<li>Hence why its an expression and not an instance of the actor object</li>\n</ul>\n</li>\n<li>\n<p>Name</p>\n<ul>\n<li>Used for routing</li>\n<li>Optional (unlike system)</li>\n<li>A GUID is used if one isn't given</li>\n<li>Should be meaningful</li>\n<li>No child of the same actor can have the same name</li>\n</ul>\n</li>\n</ul>\n</aside>\n</section><section>\n<h1>Sending Messages</h1>\n<pre><code class=\"language-csharp\">public class ExampleMessage\n{\n  public ExampleMessage(string exampleData)\n  {\n    ExampleData = exampleData;\n  }\n\n  public string ExampleData {get; }\n}\n</code></pre>\n<pre><code class=\"language-csharp\">IActorRef rootActor = _system.ActorOf(Props.Create(() => new ExampleRootActor()), \"example-root-actor-name\");\n\n//Send message to root actor via actor ref\nrootActor.Tell(new ExampleMessage(\"Example message information\"));\n</code></pre>\n<aside class=\"notes\">\n<ul>\n<li>Messages are\n<ul>\n<li>Simple POCO classes</li>\n<li>Immutable</li>\n<li>Serialisable</li>\n<li>Small (if large pass a handle)</li>\n</ul>\n</li>\n<li>Tell is fire-and-forget, does not block thread, wait for response</li>\n</ul>\n</aside>\n</section><section>\n<h1>Writing your own Actor</h1>\n<pre><code class=\"language-csharp\">public class ExampleRootActor : ReceiveActor\n{\n  public ExampleRootActor()\n  {\n    // Run the following lambda when a message is sent to this actor of type ExampleMessage\n    Receive&#x3C;ExampleMessage>(m => ReceiveExampleMessage(m));\n  }\n\n  private void ReceiveExampleMessage(ExampleMessage exampleMessage)\n  {\n    Console.WriteLine(exampleMessage.ExampleData);\n  }\n\n  public class ExampleMessage\n  {\n    public ExampleMessage(string exampleData)\n    {\n      ExampleData = exampleData;\n    }\n\n    public string ExampleData {get; }\n  }\n}\n</code></pre>\n<aside class=\"notes\">\n<ul>\n<li>Inherit from ActorBase class</li>\n<li>Different classes are available for different extensions</li>\n<li>Give the actor a lambda to call for each type it receives (I'll call them receive callbacks)</li>\n<li>Private methods for each message type</li>\n<li>Ignore messages that have no callbacks</li>\n<li>First matching receive callback wins by default</li>\n<li>The receive actor is like Akka's method of pattern matching</li>\n</ul>\n</aside>\n</section><section>\n<h1>Child Actors</h1>\n<pre><code class=\"language-csharp\">public class ExampleRootActor : ReceiveActor\n{\n  private readonly IActorRef _exampleActorRef;\n\n  public ExampleRootActor()\n  {\n    // Create child actor\n    _exampleActorRef = Context.ActorOf(Props.Create(() => new ExampleChildActor()), \"example-child-actor\");\n    // Send child actor a message\n    _exampleActorRef.Tell(new ExampleMessage(\"Example message information\"));\n  }\n}\n</code></pre>\n<aside class=\"notes\">\n<ul>\n<li>Context exposes same Actor Of method as system</li>\n<li>Context is populated by ActorOf method</li>\n<li>Another reason why actor handles the actual newing up for us</li>\n</ul>\n</aside>\n</section><section>\n<h1>Sending messages to parent</h1>\n<pre><code class=\"language-csharp\">public class ExampleChildActor : ReceiveActor\n{\n  public ExampleChildActor()\n  {\n    Receive&#x3C;ExampleMessage>(m => ReceiveExampleMessage(m));\n  }\n\n  private void ReceiveExampleMessage(ExampleMessage exampleMessage)\n  {\n    // Process message\n    Console.WriteLine(exampleMessage.ExampleData);\n\n    // Send a new message to parent actor\n    Context.Parent.Tell(new ExampleSuccessMessage());\n  }\n\n  public class ExampleSuccessMessage { }\n}\n</code></pre>\n</section><section>\n<h1>Sending messages to self</h1>\n<pre><code class=\"language-csharp\">public class ExampleSelfTellActor : ReceiveActor\n{\n  public ExampleSelfTellActor()\n  {\n    Receive&#x3C;ExampleMessage>(m => ReceiveExampleMessage(m));\n    Receive&#x3C;ExampleSelfMessage>(m => ReceiveExampleSelfMessage(m));\n  }\n\n  private void ReceiveExampleMessage(ExampleMessage exampleMessage)\n  {\n    // Process message\n    Console.WriteLine(exampleMessage.ExampleData);\n\n    // Send a new message to self\n    Self.Tell(new ExampleSelfMessage());\n  }\n\n  private void ReceiveExampleSelfMessage(ExampleSelfMessage exampleSelfMessage)\n  {\n    // TODO Process message sent to self here\n  }\n\n  public class ExampleMessage\n  {\n    public ExampleMessage(string exampleData)\n    {\n      ExampleData = exampleData;\n    }\n\n    public string ExampleData {get; }\n  }\n\n  private class ExampleSelfMessage { }\n}\n</code></pre>\n<aside class=\"notes\">\n- Puts message at back of queue\n- Allows actor to process other messages in the mean time\n- Actors don't differentiate between messages sent from other actors or themselves\n- Nesting classes inside actors allows them to be private\n</aside>\n</section><section>\n<h1>Replying to messages</h1>\n<pre><code class=\"language-csharp\">public class ExampleReplyActor : ReceiveActor\n{\n  public ExampleReplyActor()\n  {\n    Receive&#x3C;ExampleRequestMessage>(m => ReceiveExampleRequestMessage(m));\n  }\n\n  private void ReceiveExampleRequestMessage(ExampleRequestMessage exampleMessage)\n  {\n    // Reply to message\n    Context.Sender.Tell(new ExampleResponseMessage($\"Successfully replying to message: {exampleMessage.ExampleData}\"));\n  }\n\n  public class ExampleRequestMessage\n  {\n    public ExampleRequestMessage(string exampleData)\n    {\n      ExampleData = exampleData;\n    }\n\n    public string ExampleData {get; }\n  }\n\n  public class ExampleResponseMessage\n  {\n    public ExampleResponseMessage(string exampleData)\n    {\n      ExampleData = exampleData;\n    }\n\n    public string ExampleData {get; }\n  }\n}\n</code></pre>\n<aside class=\"notes\">\n<ul>\n<li>Send message to the actor that sent the message to you</li>\n<li>Use Context.Sender</li>\n</ul>\n</aside>\n</section><section>\n<h1>Receiving Replies</h1>\n<pre><code class=\"language-csharp\">public class ExampleAskActor : ReceiveActor\n{\n  private readonly IActorRef _exampleReplyActorRef;\n\n  public ExampleAskActor()\n  {\n    ReceiveAsync&#x3C;Start>(ReceiveStartAsync);\n    _exampleReplyActorRef = Context.ActorOf(Props.Create(() => new ExampleReplyActor()), \"example-reply-actor-name\");\n  }\n\n  private async Task ReceiveStartAsync(Start start)\n  {\n    ExampleReplyActor.ExampleResponseMessage result = await _exampleReplyActorRef.Ask&#x3C;ExampleReplyActor.ExampleResponseMessage>(new ExampleReplyActor.ExampleRequestMessage(\"Hello, World\"));\n\n    // The following will print \"Successfully replying to message: Hello, World\"\n    Console.WriteLine(result.ExampleData);\n  }\n\n  public class Start { }\n}\n</code></pre>\n<aside class=\"notes\">\n<ul>\n<li>Aks method creates a task that resolves when message of requested type is replied</li>\n<li>Note use of ReceiveAsync</li>\n<li>Don't have to use ask, you can receive replied messages just like any other message</li>\n</ul>\n</aside>\n</section><section>\n<h1>Behaviours</h1>\n<pre><code class=\"language-csharp\">public class ExampleBehaviorActor : ReceiveActor\n{\n  public ExampleBehaviorActor()\n  {\n    Become(Starting);\n  }\n\n  private void Starting()\n  {\n    Receive&#x3C;ExampleMessageType1>(m => ReceiveExampleMessageType1(m));\n  }\n\n  private void Started()\n  {\n    Receive&#x3C;ExampleMessageType2>(m => ReceiveExampleMessageType2(m));\n  }\n\n  private void ReceiveExampleMessageType1(ExampleMessageType1 exampleMessage)\n  {\n    //TODO: do something with first message type that would make actor ready for second message type\n    Become(Started);\n  }\n  \n  private void ReceiveExampleMessageType2(ExampleMessageType2 exampleMessage)\n  {\n    //TODO: do something with second message type\n  }\n\n  public class ExampleMessageType1 { }\n\n  public class ExampleMessageType2 { }\n}\n</code></pre>\n<aside class=\"notes\">\n<ul>\n<li>Change receive callbacks at run time</li>\n<li>Use Become method</li>\n<li>Note that receive callbacks are not carried over to new behaviours</li>\n</ul>\n</aside>\n</section><section>\n<h1>Stashing</h1>\n<pre><code class=\"language-csharp\">public class ExampleStashActor : ReceiveActor, IWithUnboundedStash\n{\n  public IStash Stash {get; set; } // Property to implement IWithUnboundedStash\n\n  public ExampleStashActor()\n  {\n    Become(Starting);\n  }\n\n  private void Starting()\n  {\n    Receive&#x3C;ExampleMessageType1>(m => ReceiveExampleMessageType1(m));\n    Receive&#x3C;ExampleMessageType2>(m => Stash.Stash()); // Stash ExampleMessageType2 when starting\n  }\n\n  private void Started()\n  {\n    Receive&#x3C;ExampleMessageType2>(m => ReceiveExampleMessageType2(m));\n    Stash.UnstashAll(); // Unstash stashed messages when started\n  }\n\n  private void ReceiveExampleMessageType1(ExampleMessageType1 exampleMessage)\n  {\n    //TODO: do something with first message type that would make actor ready for second message type\n    Become(Started);\n  }\n  \n  private void ReceiveExampleMessageType2(ExampleMessageType2 exampleMessage)\n  {\n    //TODO: do something with second message type\n  }\n\n  public class ExampleMessageType1 { }\n\n  public class ExampleMessageType2 { }\n}\n</code></pre>\n<aside class=\"notes\">\n<ul>\n<li>Often used with behaviours</li>\n<li>In memory list of messages</li>\n<li>Implement IWithUnboundedStash</li>\n<li>Stash is populated by ActorOf</li>\n<li>Stash method puts current message in stash</li>\n<li>Unstash method keeps message order and places them at the front of the queue</li>\n</ul>\n</aside>\n</section><section>\n<h1>PipeTo</h1>\n<pre><code class=\"language-csharp\">public class ExamplePipeToActor : ReceiveActor\n{\n  private readonly IThingyDoer _thingyDoer;\n\n  public ExamplePipeToActor(IThingyDoer thingyDoer)\n  {\n    _thingyDoer = thingyDoer;\n    Receive&#x3C;ExampleRequestMessage>(m => ReceiveExampleRequestMessage(m));\n    Receive&#x3C;ExampleResponseMessage>(m => ReceiveExampleResponseMessage(m));\n  }\n\n  private void ReceiveExampleRequestMessage(ExampleRequestMessage request)\n  {\n    _thingyDoer\n      .DoAsync(request.ExampleData)\n      .ContinueWith(\n        task => new ExampleResponseMessage(task.Result),\n        TaskContinuationOptions.ExecuteSynchronously)\n      .PipeTo(Self);\n  }\n\n  private void ReceiveExampleResponseMessage(ExampleResponseMessage response)\n  {\n    Console.WriteLine(response.ExampleData);\n  }\n\n  public class ExampleRequestMessage\n  {\n    public ExampleRequestMessage(string exampleData)\n    {\n      ExampleData = exampleData;\n    }\n\n    public string ExampleData {get; }\n  }\n\n  private class ExampleResponseMessage\n  {\n    public ExampleResponseMessage(string exampleData)\n    {\n      ExampleData = exampleData;\n    }\n\n    public string ExampleData {get; }\n  }\n}\n</code></pre>\n<aside class=\"notes\">\n<ul>\n<li>PipeTo is good because awaiting a task blocks an actor which is awful for performance</li>\n<li>Note the private class that allows you to scope messages to one actor only</li>\n</ul>\n</aside>\n</section><section>\n<h1>Bells &#x26; Whistles</h1>\n<pre><code class=\"language-csharp\">public class DownloadActor : ReceiveActor, IWithUnboundedStash\n{\n  private HttpClient _client;\n\n  public DownloadActor()\n  {\n    Become(Idle);\n  }\n\n  public IStash Stash {get; set; }\n\n  protected override void PreStart()\n  {\n    _client = new HttpClient();\n    base.PreStart();\n  }\n\n  protected override void PostStop()\n  {\n    _client.Dispose();\n    base.PostStop();\n  }\n\n  private void Idle()\n  {\n    Receive&#x3C;Download>(start =>\n    {\n      _client\n        .GetAsync(start.Url)\n        .PipeTo(\n          Self,\n          Self,\n          httpRes => new DownloadComplete(httpRes.Content),\n          exception => new DownloadFailure());\n      Become(Downloading);\n    });\n  }\n\n  private void Downloading()\n  {\n    ReceiveAsync&#x3C;DownloadComplete>(async download =>\n    {\n      string content = await download.Content.ReadAsStringAsync();\n      Context.Parent.Tell(new DownloadResult(content));\n      Stash.UnstashAll();\n      Become(Idle);\n    });\n    Receive&#x3C;DownloadFailure>(failure =>\n    {\n      Context.Parent.Tell(failure);\n      Stash.UnstashAll();\n      Become(Idle);\n    });\n    Receive&#x3C;Download>(start => Stash.Stash());\n  }\n\n  public class Download\n  {\n    public string Url {get; }\n\n    public Download(string url)\n    {\n      Url = url;\n    }\n  }\n\n  private class DownloadComplete\n  {\n    public HttpContent Content {get; }\n\n    public DownloadComplete(HttpContent content)\n    {\n      Content = content;\n    }\n  }\n\n  public class DownloadResult\n  {\n    public string Content {get; }\n\n    public DownloadResult(string content)\n    {\n      Content = content;\n    }\n  }\n\n  public class DownloadFailure { }\n}\n</code></pre>\n</section>"}},"pageContext":{"slug":"/akka-guide/"}},"staticQueryHashes":[]}