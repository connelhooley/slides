{"componentChunkName":"component---src-templates-presentation-js","path":"/git-guide/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Git Guide"},"html":"<section>\n<h1>Git Guide</h1>\n</section><section>\n<p>This guide aims to introduce you to git and is targeted at devs who currently use TFVC</p>\n</section><section>\n<h1>Why is git popular?</h1>\n<ul>\n<li>Better tooling support for non Visual Studio devs</li>\n<li>Better suited for open source development</li>\n<li>Better suited for feature branching</li>\n<li>The cost of supporting more than one VC system in build pipelines has resulted in products such as VSTS offering features in git before TFVC</li>\n</ul>\n<aside className=\"notes\">\n<ul>\n<li>I think the \"new branches for user stories\" feature in VSTS works in git but not TFVC</li>\n</ul>\n</aside>\n</section><section>\n<p>Git is usually used from within your IDE but lets start off by running through some basic usage of git from the command line...</p>\n</section><section>\n<p>When using git the first thing you need to do is tell it who you are by using the <strong>git config</strong> command:</p>\n<p><img src=\"/377c89ae28d256cbccdf2128ccbf69e3/git-0.png\" alt=\"\"></p>\n<small>\n<p>Normally your IDE does this for you</p>\n</small>\n</section><section>\n<p>Lets make our current directory a git repository by running the <strong>git init</strong> command:</p>\n<p><img src=\"/2eed16d6e1fc52fcff4500a3385885ea/git-1.png\" alt=\"\"></p>\n<ul>\n<li>Creates a hidden <strong>.git</strong> folder that git uses to store stuff</li>\n<li>Think of a <strong>repository</strong> as a TFVC workspace</li>\n</ul>\n</section><section>\n<p>Lets create a file in the workspace and put some text in it:</p>\n<p><img src=\"/5a3ff2b77a70472b24faa3b4bc42234f/git-2.png\" alt=\"\"></p>\n</section><section>\n<p>Now lets run <strong>git status</strong> to see the current status of our workspace:</p>\n<p><img src=\"/cfc21a60edb095529b00c7dac8a70610/git-3.png\" alt=\"\"></p>\n<ul>\n<li>This command tells you which files are to be included in the next commit</li>\n<li>A <strong>commit</strong> is the same as a check-in apart from it is entirely local</li>\n</ul>\n</section><section>\n<p><img src=\"/cfc21a60edb095529b00c7dac8a70610/git-3.png\" alt=\"\"></p>\n<ul>\n<li>As you can see we now have untracked files:</li>\n<li>We need to <strong>add</strong> them to include them in our next commit (change set)</li>\n</ul>\n</section><section>\n<p>So lets do that:</p>\n<p><img src=\"/47dd9ea6579be2e498172b7c76b6683d/git-4.png\" alt=\"\"></p>\n<p>Think of this as <strong>including pending changes</strong></p>\n</section><section>\n<p>Now lets run <strong>git status</strong> again:</p>\n<p><img src=\"/9e2c9a1800bb6fca78800c8c3c905bc8/git-5.png\" alt=\"\"></p>\n<p>Now our changes are <strong>committed</strong> which means they will be in our next commit</p>\n</section><section>\n<p>Now lets run <strong>git commit</strong> to check in our changes</p>\n<p><img src=\"/7364714b74321c73dedeec297a33c22c/git-6.png\" alt=\"\"></p>\n</section><section>\n<h1>Git Commit</h1>\n<p>Unlike TFVC where checking in sends the changes up to a remote server, git commits are entirely local</p>\n<small>\n<p><em>We'll get to sending the changes to a remote server later</em></p>\n</small>\n</section><section>\n<p>Lets run <strong>git log</strong> to view our history of commits:</p>\n<p><img src=\"/39115167782a4e119bbf00fbceaac585/git-7.png\" alt=\"\"></p>\n</section><section>\n<p><img src=\"/39115167782a4e119bbf00fbceaac585/git-7.png\" alt=\"\"></p>\n<ul>\n<li>Notice the hash written in yellow next to the word commit, this is the commit ID</li>\n<li>Think of this as a <strong>change set ID</strong></li>\n<li>A commit ID is a SHA-1 hash</li>\n</ul>\n</section><section>\n<p>Lets decrypt the commit ID hash to see what's inside it using the <strong>git cat-file</strong> command:</p>\n<p><img src=\"/d528f114c57675ecdc73e4c96d69a4e0/git-8.png\" alt=\"\"></p>\n<ul>\n<li>Everything here looks pretty standard apart from the tree which is another SHA-1 hash</li>\n<li>A <strong>tree</strong> is git speak for a directory</li>\n<li>This means the commit ID is a hash of a hash along side some metadata</li>\n</ul>\n</section><section>\n<p>Lets decrypt the tree SHA-1 hash:</p>\n<p><img src=\"/b4b29105e95a2453b2b6c0dff922d550/git-9.png\" alt=\"\"></p>\n<ul>\n<li>This tree contains a blob called helloworld.txt</li>\n<li>A <strong>blob</strong> is git speak for the contents of a file</li>\n</ul>\n</section><section>\n<p>Lets decrypt the blob SHA-1 hash:</p>\n<p><img src=\"/db5aa6c87f45a08fa4b4821d0e3c556d/git-10.png\" alt=\"\"></p>\n<p>As you can see it contains the file contents</p>\n</section><section>\n<h1>Git Object Hierarchy</h1>\n<p><img src=\"/81cd1e28f288954c2ff837176069f5e2/git-object-hierarchy-1.png\" alt=\"\"></p>\n<small>\n<p>It's hashes all the way down</p>\n</small>\n</section><section>\n<p>Lets add some new files to our workspace:</p>\n<p><img src=\"/da266bf25078cc0bb48233cd9aab8ad4/git-11.png\" alt=\"\"></p>\n</section><section>\n<p>Lets include them in our changes (add)<br>\nand check them in (commit):</p>\n<p><img src=\"/75c585f51bef6a22f699fbe18739f1cf/git-12.png\" alt=\"\"></p>\n</section><section>\n<p>Lets view our history again</p>\n<p><img src=\"/29244ccf5bec8ef85000a587c664c2f8/git-13.png\" alt=\"\"></p>\n<p>We now have 2 commits</p>\n</section><section>\n<p>Lets decrypt the latest commit ID to see what's inside it:</p>\n<p><img src=\"/740e3d05d76f8f4009015afa7baf2bbd/git-14.png\" alt=\"\"></p>\n<ul>\n<li>This commit has a parent which is the previous commit</li>\n<li>This means that even if two workspaces contain the exact same files &#x26; folders, unless they share the exact same history and were created at the exact same time, their commit IDs will be different</li>\n<li>This means that if you commit some changes, then remove the changes and commit again, then the commit ID will be different despite the workspace being the same</li>\n</ul>\n</section><section>\n<p>Lets decrypt the tree to see what's inside it:</p>\n<p><img src=\"/4827f202c45765a7c8f27e9641ef6573/git-15.png\" alt=\"\"></p>\n<p>As you can see, trees can contain multiple files &#x26; directories just like the file system</p>\n</section><section>\n<p>Lets decrypt the new directory to see what's inside it:</p>\n<p><img src=\"/cea8c8fda1031d3c4c2c300826969879/git-16.png\" alt=\"\"></p>\n<p>The tree contains the new files as expected</p>\n</section><section>\n<p>For completeness lets just decrypt one of the new files:</p>\n<p><img src=\"/717bd396f5021bed588cd568cba358c5/git-17.png\" alt=\"\"></p>\n</section><section>\n<h1>Git Object Hierarchy</h1>\n<p><img src=\"/2eff1cee619a66e0759b99bfe431c1dd/git-object-hierarchy-2.png\" alt=\"\"></p>\n</section><section>\n<p>Lets put the exact same content into 2 different files:</p>\n<p><img src=\"/989b41e73beeb80afa3b61bad893d94e/git-18.png\" alt=\"\"></p>\n</section><section>\n<p>Running <strong>git status</strong> tells us we have unstaged changes:</p>\n<p><img src=\"/312b930bff2ebba4c6d2715fa2062d56/git-19.png\" alt=\"\"></p>\n<p>You may notice that this run of git status talks about the files being unstaged as opposed to untracked like earlier...</p>\n</section><section>\n<h1>Untracked vs unstaged</h1>\n<ul>\n<li>An <strong>untracked</strong> file is a brand new file that has been newly created</li>\n<li>An <strong>unstaged</strong> file is a file that has been previously committed, but has since been modified</li>\n<li>This is always abstracted away from you by your IDE so don't worry about it too much</li>\n</ul>\n</section><section>\n<p>Adding the files includes them in our commit:</p>\n<p><img src=\"/6a64a145fd03fc6e291f7d1adbc46de8/git-20.png\" alt=\"\"></p>\n<p>In git land this is usually called <strong>staging</strong> your changes</p>\n</section><section>\n<p>Lets commit our changes:</p>\n<p><img src=\"/be7ba8961e4cb8474027401ed20e2ec2/git-21.png\" alt=\"\"></p>\n</section><section>\n<p>We can now see our history contains 3 commits:</p>\n<p><img src=\"/a5ed347215cb51277aeac1fe05e0a727/git-22.png\" alt=\"\"></p>\n</section><section>\n<p>Lets view our new object tree in the terminal:</p>\n<p><img src=\"/66e917f5862df5eed0e0abd8d514fb3e/git-23.png\" alt=\"\"></p>\n<ul>\n<li>Note how both subfolderfile1.txt and subfolderfile2.txt have the exact <strong>same</strong> hash</li>\n<li>This demonstrates how efficient git is when storing files locally</li>\n</ul>\n</section><section>\n<h1>Git Object Tree</h1>\n<p><img src=\"/62016885d81cb64ab2aa081d86c4bda9/git-object-hierarchy-3.png\" alt=\"\"></p>\n</section><section>\n<p>Lets look at actually where git stores these objects on the disk</p>\n<p><img src=\"/203d0789d0a58c6b42cd3867bad17bc6/git-24.png\" alt=\"\"></p>\n</section><section>\n<h1>Storage</h1>\n<ul>\n<li>Git stores files in the hidden directory. They are placed in:\n<ul>\n<li>A directory that is named after the first 2 letters of the hash</li>\n<li>A file that is named after the subsequent 38 character of the hash</li>\n</ul>\n</li>\n<li>The object files in the hidden directory are compressed so cannot be opened without using special git commands</li>\n</ul>\n</section><section>\n<p>You may have noticed that the blob hash for the original helloworld.txt never changed during any of the commits</p>\n<p>This means that every commit represents a snapshot of all the files on the disk during the time of the commit, but the same file contents is never stored twice</p>\n</section><section>\n<p>Lets look at working with remote servers...</p>\n</section><section>\n<p>It is possible to create git repositories that are hosted by a provider</p>\n<small>\n<p>This is common practice</p>\n</small>\n</section><section>\n<p>Creating a remote repository varies per provider, but it is usually a very simple process</p>\n<p><img src=\"/14236d5b5501cd6b9e70f711fd4d47bf/vsts-remote-repository-creating.png\" alt=\"\"></p>\n</section><section>\n<p>Once you have created a remote repository you then have two options. You can either:</p>\n<ul>\n<li>Take a local repository that you have already created by running <strong>git init</strong> and upload it to the empty remote repository</li>\n<li>Download the empty remote repository to your machine</li>\n</ul>\n</section><section>\n<p>The git hosting provider will usually give you hints on how to do both:</p>\n<p><img src=\"/3cad09097e54743a89ff8d27bef3879b/vsts-remote-repository-created.png\" alt=\"\"></p>\n</section><section>\n<h1>Auth</h1>\n<ul>\n<li>When accessing VSTS git repositories from Visual Studio you are authenticated automatically</li>\n<li>When accessing the repository from the command-line like we are, we need to generate <strong>git credentials</strong></li>\n<li>This is a username and password that can only be used to access the git repository</li>\n<li>Visual Studio uses a more advanced token based system to authenticate git users</li>\n</ul>\n</section><section>\n<p>Lets do that now by clicking on generate git credentials:</p>\n<p><img src=\"/ca9afb234ac4b50a37cd91d0783c46d9/vsts-remote-repository-created-credentials-1.png\" alt=\"\"></p>\n</section><section>\n<p>Then simply fill in the form:</p>\n<p><img src=\"/893e181534058f94d7d3006d59ba790b/vsts-remote-repository-created-credentials-2.png\" alt=\"\"></p>\n<small>\n<p>Normally you don't need to do this since you'll be using Visual Studio</p>\n</small>\n</section><section>\n<p>Now lets download the repository to our machine by running the <strong>git clone</strong> command with the URL that VSTS\ngave us:</p>\n<p><img src=\"/a46e54403ed72fc6c4c7430a58bb27f9/git-25.png\" alt=\"\"></p>\n</section><section>\n<p>The git clone command creates a sub directory that is a local git repository. You can create local commits in\nthis repository and then push them up to the server.</p>\n</section><section>\n<p>Alternatively, if you've already got a local git repository then you can push it up to the server instead of\ncloning</p>\n</section><section>\n<p>Lets push our git repository we worked on earlier to the remote VSTS repository we have created:</p>\n<p><img src=\"/76fda5f2367100e7ebb3a9d4a8777559/git-26.png\" alt=\"\"></p>\n</section><section>\n<p>We can now see the contents of our remote repository in VSTS:</p>\n<p><img src=\"/09dd73f8fc0ebd04529459b9926e27d6/vsts-remote-repository-pushed.png\" alt=\"\"></p>\n</section><section>\n<p>Regardless of whether we cloned a remote repository to our machine or pushed our local repository to the remote server, we now have a local repository that is \"linked\" to a remote repository.</p>\n</section><section>\n<p>We can see this \"link\" configured inside git's <strong>config</strong> file that you can find in the hidden <strong>.git</strong> folder:</p>\n<p><img src=\"/0a6cfa1a2fdde84b752d9a48fc27efe4/git-remote-config.png\" alt=\"\"></p>\n<p>Here you can see we have one branch called <strong>master</strong> and one remote repository called <strong>origin</strong>.</p>\n</section><section>\n<p>You can have many remote repository linked to your local repository but this is rare.</p>\n<p>The convention is to call your remote repository <strong>origin</strong>.</p>\n<p>We will go through branches later.</p>\n</section><section>\n<p>Lets make some local changes to the repo we pushed up to VSTS by modifying a file:</p>\n<p><img src=\"/22f0ee859ca30d72f54bf7d79a7d62fd/git-27.png\" alt=\"\"></p>\n<ul>\n<li>Note that it says: Your branch is one commit ahead of 'origin/master'</li>\n<li>This means that our local master branch has one commit that the remote master branch doesn't have</li>\n</ul>\n</section><section>\n<p>Lets make another commit modifying the same file:</p>\n<p><img src=\"/4d51555ffddd9f3ec0f1a934a867ebdf/git-28.png\" alt=\"\"></p>\n<p>We're now 2 ahead of master</p>\n</section><section>\n<p>We can now <strong>push</strong> our commit to the remote VSTS repository:</p>\n<p><img src=\"/af4a2f52e399de44019ab0125264ab58/git-29.png\" alt=\"\"></p>\n</section><section>\n<p>Annoyingly most of the message is about a change in behaviour that was introduced in git 2. That's embrace the new behaviour and stop that message appearing in the future:</p>\n<p><img src=\"/44dac0c95957ce15a2387e698d3ab07d/git-30.png\" alt=\"\"></p>\n</section><section>\n<p>If we look at VSTS we can see it knows about both of the new commits now:</p>\n<p><img src=\"/ed9b2c5ecc51ec71e20175b6ad88757c/vsts-commit-history-1.png\" alt=\"\"></p>\n</section><section>\n<p>This allows us to make our commit messages in git much more descriptive than our check-in messages in TFVC.</p>\n</section><section>\n<p>Since we are in control of when others can see our changes, we can make lots of small commits with descriptive messages and then push them when we are ready.</p>\n<p>This is in contrast to TFVC messages where you only describe your changes when you're ready to publish them, resulting in a larger amount of changes needing to be described.</p>\n</section><section>\n<p>Commit messages are also mandatory, you must provide one - unlike check-in messages</p>\n</section><section>\n<p>Lets make a change on the remote server that isn't on our machine:</p>\n<p><img src=\"/8fa9cd103e54ac9896cc1579faf19303/vsts-modifying-file-remotely.png\" alt=\"\"></p>\n<small>\n<p>This is the same as someone else making a commit, and then pushing it to the remote repository</p>\n</small>\n</section><section>\n<p>Lets pull that change down to our machine using the <strong>git pull</strong> command:</p>\n<p><img src=\"/87401da5aaeb0b4ac26452f90a90159d/git-31.png\" alt=\"\"></p>\n</section><section>\n<h1>Lets recap what we've seen so far...</h1>\n</section><section>\n<h1>git repository<br />==<br />TFVC workspace</h1>\n</section><section>\n<h1>git commit<br />==<br />TFVC changeset</h1>\n</section><section>\n<h1>git commit &#x26;&#x26; git push<br />==<br />TFVC check-in</h1>\n<p><img src=\"/72394d6a2efb2e09030bccc36722d099/push.png\" alt=\"\"></p>\n</section><section>\n<h1>git pull<br />==<br />TFVC get latest</h1>\n<p><img src=\"/fa15aa6d865e15bb5b8ba96b8231146a/pull.png\" alt=\"\"></p>\n</section><section>\n<h1>git staging changes<br />==<br />TFVC include pending changes</h1>\n</section><section>\n<h1>git commit id<br />==<br />TFVC changeset id</h1>\n</section><section>\n<p>Lets see what all this looks like in Visual Studio...</p>\n</section><section>\n<p>After we've made some changes in our local repository we can review our changes inside the changes window:</p>\n<p><img src=\"/2553a84c372a61c2b60a26c53ed17c00/vs-commit.png\" alt=\"\"></p>\n<p>By default all changes are staged</p>\n</section><section>\n<p>You can also choose which files to commit by using the right click menu to stage only some of them:</p>\n<p><img src=\"/29dc0d416b3454cf052aa185f6af9145/vs-commit-stage.png\" alt=\"\"></p>\n</section><section>\n<p>If you choose to stage only certain files, then the other files are unstaged:</p>\n<p><img src=\"/c999319d794feff159f7871738e91d80/vs-commit-staged.png\" alt=\"\"></p>\n</section><section>\n<p>Once you have committed, you need to push your changes to the server. To do this click on sync:</p>\n<p><img src=\"/b0d5e6c22f47f4981cbbe05ed739c913/vs-committed.png\" alt=\"\"></p>\n</section><section>\n<p>Visual Studio has a feature called <strong>sync</strong>\nSync just calls <strong>pull</strong> then <strong>push</strong></p>\n</section><section>\n<p>Clicking on the blue <strong>sync</strong> link underneath the branch name performs a sync</p>\n<p><img src=\"/1526e0069068d0696228c4f38b9dc552/vs-sync-1.png\" alt=\"\"></p>\n<p>The local repository and the server will then have the same code for the current branch</p>\n</section><section>\n<p>You can view commits by right clicking on the solution and then clicking on history:</p>\n<p><img src=\"/3374f54b1bed42247cc10d8dffa9ac3a/vs-commit-history.png\" alt=\"\"></p>\n</section><section>\n<p>The read arrows on the right-hand side point to which commit the local and remote repositories consider to the latest:</p>\n<p><img src=\"/1b417ba25a7087ebc0dc1ac0a070986b/vs-commit-history-head.png\" alt=\"\"></p>\n<p>This means our local branch is 1 commit ahead of the remote repository</p>\n</section><section>\n<p>Lets create a new branch inside our repository:</p>\n<p><img src=\"/de41eeed54ebf6b0793aa2b72aa77fb8/git-32.png\" alt=\"\"></p>\n<p>This command creates a branch and \"switches\" to it</p>\n</section><section>\n<p>Unlike in VSTS where branches are represented in mapped folders, git repositories manage different branches by allowing you to switch between them.</p>\n<p>When you switch branches your workspace is changed to represent the branch you're changing to.</p>\n</section><section>\n<p>Having lots of branches on your machine doesn't actually take up as much room as you'd think since git is efficient and only ever stores the same version of a file once. Normally branches will have more in common than\ndifferences.</p>\n<p>When you switch branches your workspace is instantly changed to represent the branch you're changing to.</p>\n</section><section>\n<p>Lets make a change in our new <em>vnext</em> branch:</p>\n<p><img src=\"/d013c78b570e2775bef513cd406dc105/git-33.png\" alt=\"\"></p>\n</section><section>\n<p>Now we can view the contents of the modified file before and after changing branches:</p>\n<p><img src=\"/81014bf6342403b9d2ca91ca39e2f902/git-34.png\" alt=\"\"></p>\n</section><section>\n<p>A branch in git is simply a link to a commit id</p>\n<p>When you perform a commit the current branch is updated to the new commit</p>\n</section><section>\n<h1>Git Object Hierarchy</h1>\n<p><img src=\"/98ae91837e069da1279c60690d288af7/git-object-hierarchy-4.png\" alt=\"\"></p>\n</section><section>\n<p>Lets make a change to our master branch that conflicts with the change in vnext:</p>\n<p><img src=\"/15d2e2634a4d51df3bf50d89b858afe8/git-35.png\" alt=\"\"></p>\n</section><section>\n<h1>Git Object Hierarchy</h1>\n<p><img src=\"/1bc2065fa425bcc214c8a14fa5f154a0/git-object-hierarchy-5.png\" alt=\"\"></p>\n</section><section>\n<p>We can now try and perform a <strong>merge</strong>:</p>\n<p><img src=\"/0743db3d87fb358ee98825f88378782b/git-36.png\" alt=\"\"></p>\n<p>Since we are currently in the master branch, this merges vnext into master</p>\n</section><section>\n<p>As expected we have a merge conflict, we can see this by running git status:</p>\n<p><img src=\"/d0c1345f089478f3f8d647fbabcf77d5/git-37.png\" alt=\"\"></p>\n</section><section>\n<p>If we look inside the conflicted file, we can see that git has put both modified versions of the conflicted line in the file:</p>\n<p><img src=\"/9913e6607ee1829530219554bb3fbb01/git-38.png\" alt=\"\"></p>\n</section><section>\n<p>We can fix the merge by modifying the file and then performing a commit:</p>\n<p><img src=\"/488d62253676922daad38045a9e68d1b/git-39.png\" alt=\"\"></p>\n<small>\n<p>Note we didn't have to specify a commit name, since our workspace was in process of performing a merge</p>\n</small>\n</section><section>\n<p>Note that if we were merging with Visual Studio then we would have the standard merge window and this would handle the extra commit command required</p>\n</section><section>\n<p>If we run <strong>git log</strong> then we can see the merge commit:</p>\n<p><img src=\"/42cb0a1440d96d5e62e81f11ab418ded/git-40.png\" alt=\"\"></p>\n</section><section>\n<p>If we decrypt the commit we find something interesting about it:</p>\n<p><img src=\"/2935dea5cc39440374da6b95cf696815/git-41.png\" alt=\"\"></p>\n<p>Merge commits have 2 parents</p>\n</section><section>\n<h1>Git Object Hierarchy</h1>\n<p><img src=\"/de8a644b0863395a5da5b33d100e6123/git-object-hierarchy-6.png\" alt=\"\"></p>\n</section><section>\n<p>Git also has a merging feature called <strong>rebase</strong></p>\n</section><section>\n<p>When merging a branch it can be difficult to track where certain changes come from</p>\n<p>Rebasing allows you to stack one branch on top of another</p>\n</section><section>\n<p>Lets make some changes in a new branch but perform a hotfix to the master branch in the process:</p>\n<p><img src=\"/0f96ae5249f682cb2307bfeb9968b891/git-42.png\" alt=\"\"></p>\n</section><section>\n<h1>Git Object Hierarchy</h1>\n<p><img src=\"/14382801d5832479da67029e80aa023a/git-object-hierarchy-7.png\" alt=\"\"></p>\n</section><section>\n<p>Now we can rebase our new-feature branch onto the latest version of the master branch:</p>\n<p><img src=\"/b5521957df1b6d77fdfa2c04d48cbc30/git-43.png\" alt=\"\"></p>\n</section><section>\n<p>If we view our last 5 commits you can see that our changes have now been made \"on top of\" our hotfix:</p>\n<p><img src=\"/687e05823062b490441ffbee831842cf/git-44.png\" alt=\"\"></p>\n</section><section>\n<h1>Git Object Hierarchy</h1>\n<p><img src=\"/196560a7bdda30565b9c40ef92da4153/git-object-hierarchy-8.png\" alt=\"\"></p>\n</section><section>\n<p>We now have a much simpler commit history, and all the new feature commits are grouped together</p>\n</section><section>\n<p>If we want our rebased changes to go into the master branch then the merge is very simple as we have all the changes from master in our branch already</p>\n</section><section>\n<p>Since our new-feature branch is now an extension of master we can do a simple merge to bring master up to date:</p>\n<p><img src=\"/27733edeb73fca5f4316ebe6a7975c31/git-45.png\" alt=\"\"></p>\n<small>\n<p>When the branch you're merging in already has all of the commits of the current branch, this is called a fast-forward merge</p>\n</small>\n</section><section>\n<h1>Git Object Hierarchy</h1>\n<p><img src=\"/c053f6987f9a8acaf68402d0b4294ff0/git-object-hierarchy-9.png\" alt=\"\"></p>\n</section><section>\n<p>Think of performing a rebase as saying:<br>\n<em><strong>\"I want my changes to be applied to the latest version of the source branch\"</strong></em></p>\n</section><section>\n<p>A git <strong>tag</strong> is a snapshot of the code at a given moment in time</p>\n</section><section>\n<p>Branches and tags are merely links to a commit</p>\n</section><section>\n<p>When a commit is made, the current branch is updated to point at the latest commit, whereas a tag does not move</p>\n</section><section>\n<p>Lets create a tag using the <strong>git tag</strong> command:</p>\n<p><img src=\"/9c081dc9d500f64738cc2612f4d1863d/git-46.png\" alt=\"\"></p>\n</section><section>\n<p>Now lets make a change to our branch:</p>\n<p><img src=\"/4530de477ddc370f5f44b5fed1b41cfe/git-47.png\" alt=\"\"></p>\n</section><section>\n<h1>Git Object Hierarchy</h1>\n<p><img src=\"/7e784a22ff72164d2835569f2781e629/git-object-hierarchy-10.png\" alt=\"\"></p>\n</section><section>\n<p>This makes tags a perfect way to track releases</p>\n</section><section>\n<p>The <strong>git push</strong> command only pushes commits from branches that the remote server knows about</p>\n</section><section>\n<p>Lets run a <strong>git push</strong> command now:</p>\n<p><img src=\"/55825b96efb6bff1cfb5a873ca706984/git-48.png\" alt=\"\"></p>\n</section><section>\n<p>If we look at VSTS we'll see that it still doesn't know about any of our branches or tags we've created locally:</p>\n<p><img src=\"/dffa261bc1b70ae69e705dfaf6a41bc9/vsts-no-branches-pushed.png\" alt=\"\"></p>\n<p><img src=\"/0524e972a941da70465ce0e94b88554a/vsts-no-tags-pushed.png\" alt=\"\"></p>\n</section><section>\n<p>We must push these branches and tags up manually</p>\n</section><section>\n<p>This is to prevent all your local experimental dev branches being uploaded</p>\n</section><section>\n<p>To push a local branch add a couple of parameters to the push command:</p>\n<p><img src=\"/9b094cfe0551b6064d1ec5a4852a2d19/git-49.png\" alt=\"\"></p>\n<small>\n<p>Visual Studio does this for you...</p>\n</small>\n</section><section>\n<p>You'll now see this branch in VSTS:</p>\n<p><img src=\"/4890781fe0ecb048f23e708a724e8249/vsts-branch-pushed.png\" alt=\"\"></p>\n</section><section>\n<p>This also works for tags:</p>\n<p><img src=\"/6fc7da075f86c67d424ec06f1c9459bd/git-50.png\" alt=\"\"></p>\n<small>\n<p>Visual Studio does <strong>not</strong> do this for you...</p>\n</small>\n</section><section>\n<p>You'll now see this tag in VSTS:</p>\n<p><img src=\"/70f805ae6e0ac70c0667ac0fa8833f31/vsts-tag-pushed.png\" alt=\"\"></p>\n</section><section>\n<p>Lets see what branching and merging looks like in Visual Studio...</p>\n</section><section>\n<p>Lets start off by creating a branch</p>\n</section><section>\n<p>Go to the Team Explorer</p>\n<p><img src=\"/60cae2bc657d582ab9e35105a79281b2/vs-team-explorer.png\" alt=\"\"></p>\n<p>And click on \"Branches\"</p>\n</section><section>\n<p>Here we can see our local and remote branches:</p>\n<p><img src=\"/55a85fa350093fc9d4fce7473f4f30ec/vs-branches-1.png\" alt=\"\"></p>\n<p>Click on \"New Branch\" to create a branch</p>\n</section><section>\n<p>Enter the name of your new branch and click on \"Create Branch\":</p>\n<p><img src=\"/1fc7a8417725adf94067e50c6d0fa1c1/vs-new-branch.png\" alt=\"\"></p>\n<small>\n<p>Leaving \"Checkout branch\" ticked means you'll switch to this branch once it is created</p>\n</small>\n</section><section>\n<p>Make some changes to a file, then go back to Team Explorer:</p>\n<p><img src=\"/60cae2bc657d582ab9e35105a79281b2/vs-team-explorer.png\" alt=\"\"></p>\n<p>And click on \"Changes\"</p>\n</section><section>\n<p>Enter your commit message and click on \"Commit All\"</p>\n<p><img src=\"/9fa4b92d99f59dcf2b81d36c0f958616/vs-changes.png\" alt=\"\"></p>\n</section><section>\n<p>Go back to Team Explorer:</p>\n<p><img src=\"/60cae2bc657d582ab9e35105a79281b2/vs-team-explorer.png\" alt=\"\"></p>\n<p>And click on \"Sync\"</p>\n</section><section>\n<p>Click on \"Push\" to push your new local branch to the remote server:</p>\n<p><img src=\"/78320827512bbe6b644bdeee1b58a4ab/vs-sync-2.png\" alt=\"\"></p>\n</section><section>\n<p>Visual Studio will tell you when it's finished:</p>\n<p><img src=\"/580978459c3b624543ba60da4ab1cb4e/vs-sync-pushed-branch.png\" alt=\"\"></p>\n</section><section>\n<p>If we go back to the Branches screen we can see there is a remote version of our new branch that others can now\nsee:</p>\n<p><img src=\"/e25af74a2d49edbb3b42ddc0473dd7ab/vs-branches-2.png\" alt=\"\"></p>\n</section><section>\n<p>The easiest way to switch branches is to use the menu on the bottom right hand corner:</p>\n<p><img src=\"/6d849e3698f8acc9df7c1886fb5b75a6/vs-switch-branch.png\" alt=\"\"></p>\n<p>Use this menu to switch between branches and then commit conflicting changes in either branch</p>\n</section><section>\n<p>Now go to the Branches screen:</p>\n<p><img src=\"/e25af74a2d49edbb3b42ddc0473dd7ab/vs-branches-2.png\" alt=\"\"></p>\n<p>And click on \"Merge\"</p>\n</section><section>\n<p>We're switched to the master branch, so lets merge our experimental branch into our master branch:</p>\n<p><img src=\"/8defcd81c0b3908a159a2027d7026045/vs-branch-merge.png\" alt=\"\"></p>\n</section><section>\n<p>Visual Studio will tell you about the conflicts:</p>\n<p><img src=\"/a06cf3436880bdef07ca7694012dbaf7/vs-branch-merge-conflicts.png\" alt=\"\"></p>\n</section><section>\n<p>If we view the conflicting file we'll see the merge text git puts in the file:</p>\n<p><img src=\"/d33eae6e3da3aa8fbbaa0abbfc89d635/vs-branch-merge-conflicts-file.png\" alt=\"\"></p>\n</section><section>\n<p>If we go back to the Changes screen we can either cancel the merge by clicking on \"Abort\" or resolve the conflicts by clicking on \"Conflicts 1\":</p>\n<p><img src=\"/a06cf3436880bdef07ca7694012dbaf7/vs-branch-merge-conflicts.png\" alt=\"\"></p>\n</section><section>\n<p>If we click on \"Conflicts 1\" then a list of files that have conflicts:</p>\n<p><img src=\"/17774338064e2b8377b6194259ed1851/vs-branch-merge-conflicts-resolve-1.png\" alt=\"\"></p>\n</section><section>\n<p>Clicking on a file gives us some options:</p>\n<p><img src=\"/86234e05d4423194900915e3fc231f87/vs-branch-merge-conflicts-resolve-2.png\" alt=\"\"></p>\n</section><section>\n<p>If we click on \"Merge\" then we see the familiar conflicts window:</p>\n<p><img src=\"/6ea1e9b37743ff84c0392d5a282d2897/vs-branch-merge-conflicts-resolve-3.png\" alt=\"\"></p>\n</section><section>\n<p>Once we have resolved the conflict we can commit our merge (or abort it):</p>\n<p><img src=\"/6e519851aaff57b40f83af119f92f82a/vs-branch-merge-conflicts-resolve-4.png\" alt=\"\"></p>\n</section><section>\n<p>Clicking on \"Commit Merge\" takes us to the commit screen:</p>\n<p><img src=\"/fe5b2a8a3af41085c29b0f54c3c1b469/vs-branch-merge-conflicts-resolve-5.png\" alt=\"\"></p>\n<p>It has a handy note saying we're in the middle of a merge</p>\n</section><section>\n<p>We can then push our merge commit to the remote repository just like any other commit</p>\n</section><section>\n<p>Git also has a feature called a <strong>pull request</strong></p>\n</section><section>\n<p>A pull request is not actually a feature of git itself, but is actually a feature that git providers offer</p>\n</section><section>\n<p>With open source projects anyone can access your source code</p>\n</section><section>\n<p>This also means they can change it to add new features</p>\n</section><section>\n<p>Open source projects require the ability to stop anyone just modifying the remote repository at will</p>\n<p>But they also require the ability to take changes from other people's repository</p>\n</section><section>\n<p>Lets run through how this works in git...</p>\n</section><section>\n<p>Imagine an open source team has an public repository:</p>\n<p><img src=\"/2e368b931cde70818e3e9cabf7aa737b/git-pr-1.png\" alt=\"\"></p>\n</section><section>\n<p>A contributor <strong>forks</strong> the remote repository into their own remote repository</p>\n<p><img src=\"/febab5498e5439ff9c7102b87c8016fa/git-pr-2.png\" alt=\"\"></p>\n</section><section>\n<p>Forking is a feature offered by a git provider, not git itself</p>\n</section><section>\n<p>The Contributor only has read access to the original repository but has read and write access to their forked copy</p>\n</section><section>\n<p>Contributors clone their forked remote repository onto their machine:</p>\n<p><img src=\"/8fcc471616cddba76c9d226f71fa705a/git-pr-3.png\" alt=\"\"></p>\n</section><section>\n<p>They make changes in their own local repository and push them up to their forked repository</p>\n<p><img src=\"/38b89a2c688e5e0fd29d10812c23c079/git-pr-4.png\" alt=\"\"></p>\n</section><section>\n<p>They then perform a <strong>pull request</strong>:</p>\n<p><img src=\"/3f2ecc8d86d8c7b1ae2a1457256f29e8/git-pr-5.png\" alt=\"\"></p>\n</section><section>\n<p>A pull request asks the original repository's owners if they would like to pull the changes from the forked repository</p>\n</section><section>\n<p>Pull requests are a feature offered by a git provider, not git itself</p>\n</section><section>\n<p>Most git providers offer a GUI including a comments/forum section where the original repository's owners can discuss the changes</p>\n</section><section>\n<p>The original repository's owners can then accept or reject the pull request:</p>\n<p><img src=\"/66fc32f405100a3c7b64766124c76152/git-pr-6.png\" alt=\"\"></p>\n</section><section>\n<p>If accepted then the original and forked repositories will contain the same code:</p>\n<p><img src=\"/9168549f52964e0bd70d9f2ca1f462ef/git-pr-7.png\" alt=\"\"></p>\n</section><section>\n<p>Because the UI for commenting on the changes and the ability to accept and reject is so useful for code reviews, some git providers also allow dev teams to perform pull requests on branch merges too</p>\n</section><section>\n<p>Lets walk through doing a pull request when merging two branches in VSTS...</p>\n</section><section>\n<small>\n<p>It brings up this form:</p>\n</small>\n<p><img src=\"/b862baead4490f038cbb62cf22dba521/vsts-pull-request-1.png\" alt=\"\"></p>\n</section><section>\n<small>\n<p>Once it is created we are then given a comments section for all the reviewers to discuss the potential\nmerge:</p>\n</small>\n<p><img src=\"/d550873d7597dcf011b588f32b691562/vsts-pull-request-2.png\" alt=\"\"></p>\n</section><section>\n<small>\n<p>We can then approve or reject the request:</p>\n</small>\n<p><img src=\"/a440b7a00df09853019b52cefcb46a09/vsts-pull-request-3.png\" alt=\"\"></p>\n</section><section>\n<small>\n<p>We can then clearly see in the discussions who's approved and rejected the request:</p>\n</small>\n<p><img src=\"/eac34b00c4c0443aba203c29d09c487f/vsts-pull-request-4.png\" alt=\"\"></p>\n<small>\n<p>We can also mark each comment as approved or rejected too</p>\n</small>\n</section><section>\n<small>\n<p>When we're ready we can complete the merge:</p>\n</small>\n<p><img src=\"/9950789a4fb39a0509ae0f8addc08b8a/vsts-pull-request-5.png\" alt=\"\"></p>\n</section><section>\n<small>\n<p>Notice the option to delete the branch, this is perfect for feature branches:</p>\n</small>\n<p><img src=\"/dc085f4064280d0a27d074d4a1ffa5e1/vsts-pull-request-6.png\" alt=\"\"></p>\n</section><section>\n<p><img src=\"/8b08602938dbe4f6941a84251b995226/vsts-pull-request-7.png\" alt=\"\"></p>\n</section><section>\n<p>Commit messages are actually separated into two parts</p>\n</section><section>\n<p>The first line of the message is the commit message</p>\n<small>\n<p>The convention is to keep this line under 72 characters long</p>\n</small>\n</section><section>\n<p>Any subsequent lines can contain a more detailed description of the commit</p>\n<small>\n<p>There is no limit to the length of the detailed description</p>\n</small>\n</section><section>\n<p>The commit message and detailed description must be separated by a new line</p>\n</section><section>\n<p>Below is an example commit messages that demonstrates this:</p>\n<pre><code>Database timeout bug fix\n\nThe user repository was not disposing of the DbContext correctly so I added a using statement.\n\n- I also updated all of the unit tests.\n- I also updated all of the integration tests.\n</code></pre>\n</section><section>\n<p>When viewing commit history in VSTS the first line is displayed as the commit message, with the rest of it being displayed as a tooltip:</p>\n<p><img src=\"/6aed5474dd8f8c3908ef6d1dc49bae9c/vsts-commit-history-2.png\" alt=\"\"></p>\n<p><img src=\"/0f1577afa6b367e750a9a06b0da3aa49/vsts-commit-history-2-tooltip.png\" alt=\"\"></p>\n</section><section>\n<p>When viewing an individual commit in VSTS the first line is displayed as the commit message, with the rest of it being accessible by clicking on ˅:</p>\n<p><img src=\"/2ae9bebbcdde99a5dae85054a29e5d69/vsts-view-commit.png\" alt=\"\"></p>\n<p><img src=\"/4e571d2046dbf6eb3a59418204fa65e3/vsts-view-commit-details.png\" alt=\"\"></p>\n</section><section>\n<h1>Thanks for listening!</h1>\n<p>Any questions?</p>\n</section>"}},"pageContext":{"slug":"/git-guide/"}},"staticQueryHashes":[]}